## 31、整数中1出现的次数（从1到n整数中1出现的次数）

**解题思路：**

我们看到题目要求 “输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数”。其实就是求从1-n这n个数中，每一个数的计数位上出现的1的个数的总和。

所以我们只需要知道在某个计数位上面1出现次数的计算方法即可求解这道题目，下面我们分为几种情况讨论：

**1、当前位上的值等于0**

![image-20210619103136978](https://gitee.com/lgaaip/img/raw/master/image-20210619103136978.png)

我们可以看到当前位为百位，即base = 100；当前位上的数为cur  = 0，此时为什么需要借位呢？

因为当cur为0的时候，后面的b即使取0-36的任何一个数，cur都不可能出现1，永远都是0。

所以需要向前借位，借位后cur才能有为1的情况，当cur借到位的时候，将cur变为1，此时我们就可以去计算1出现的个数了。

此时a的取值范围为 0-513，然后b的范围为0-99。0-513这个好理解，因为被cur借去了一位，但是b不是刚开始只能取0-36吗？为什么就能够变成0-99呢？我们看到，当cur向前借位的时候，cur是可以取0-9任意一个数的，因为我们就是想让cur为1，所以**cur这一位完全可以提供给后面的借位**，所以b的取值可以为 0-99。

好了，上面说了那么多，此时这种情况下，1出现的次数怎么算呢？

我们可以转化为这么想，当cur为1的时候，最多能够生成多少个cur为1的数呢？不就是cur前面能变换的个数乘上后面能变换的个数吗？

所以n = 514036的时候，cur为1出现的次数 **res = a X base**。

**2、当前位上的值等于1时**

![image-20210619110657754](https://gitee.com/lgaaip/img/raw/master/image-20210619110657754.png)

我们可以从上图很清楚的看到，此时cur=1，并且当a为514的时候，b只能取0-36，此时 **res1 = 1 * (b+1)**

当a取值 0-519 的时候，b就能够取 0-99 。此时 **res2 = a * base**

所以总的就为 **res = res1 + res2**



**3、当前位上的值大于1时**

![image-20210619111157276](https://gitee.com/lgaaip/img/raw/master/image-20210619111157276.png)

我们可以得到a和b的取值范围，至于b为什么又是0-99而不是0-36，解释跟上面一样。

所以 **res = (a+1) X base**（tips : 0-514 为 a+1 个数）



**代码**

Java版

```java
public int NumberOf1Between1AndN_Solution(int n) {
        // 从个位数开始
        int base = 1;
    	// 总的出现1的次数现在为 0
        int res = 0;
    	// 不能超过n
        while(base <= n){
            // 求出当前位 ，高位，低位
            int cur = n/base%10;
            int a = n/base/10;
            int b = n%base;
  
            // 分三类情况讨论，对于上面解释的三种情况
            if(cur > 1)
                res += (a+1)*base;
            else if(cur == 0)
                res += a*base;
            else res += a*base+b+1;
            base *= 10; // 位数向前以移一位
        }
        return res; // 最后得到全部出现1的次数，返回
    }
```

Go版

```golang
func NumberOf1Between1AndN_Solution( n int ) int {
    // write code here
    // 从个位数开始
    base,res := 1,0
    for base <= n {
        // 当前位
        cur := n/base%10
        // 高位
        a := n/base/10
        // 低位
        b := n%base
        
        // 对应三种情况
        if cur > 1 {
           res += (a+1)*base
        }else if cur == 0 {
           res = res + a*base
        }else{ res = res + a*base+b+1}
        base *= 10
    }
    return res
}
```



**复杂度分析：**

时间复杂度 O(logn) ： 循环次数为n的位数，所以为 log10(n)，即时间复杂度为 O（log10N）。

空间复杂度 O(1) ： 常量的空间。



## 32、把数组排成最小的数

**解题思路**：

要注意题目的意思是把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

这道题目可以看成是一道排序的题目，因为要使得结果最小，那么给出的整数要怎么排列呢？
其实就可以转化为 A+B 与 B+A 之间比较的问题（`注意`：这里的A+B并不是A加上B，而是A拼上B），当A+B小于B+A的时候，很明显A要放在B的前面，这样才能使得结果小。

举个例子：

> 当A = 206，B = 1
>
> 此时 A+B = 2061  B+A = 1206
>
> 我们可以看到 A+B > B+A，所以很明显B需要放在A的前面，即B+A，才能使得拼出来的数字最小。

我们在来看张动图：

![32](https://gitee.com/lgaaip/img/raw/master/32.gif)

所以总体的逻辑就是：

> 1、先将整型数组转化为字符串型数组
>
> 2、定义特定排序规则
>
> 3、用定义的排序规则对字符串型数组进行排序
>
> 4、将字符串型数组中每个元素拼接起来
>
> 5、得到最小的数



**代码：**

Java版

```java
public String PrintMinNumber(int [] numbers) {
        if(numbers == null || numbers.length == 0)
            return "";
        int n = numbers.length;
        String[] nums = new String[n];
    	// 先将整型数组转化为字符串型数组
        for(int i = 0; i < n; i++){
            nums[i] = numbers[i]+"";
        }
    	// 用定义的排序规则对字符串型数组进行排序
        Arrays.sort(nums,(s1,s2)->{
           return (s1+s2).compareTo(s2+s1);
        });
    
        StringBuffer sb = new StringBuffer();
    	// 将字符串型数组中每个元素拼接起来
        for(String num:nums)
            sb.append(num);
        return sb.toString();
    }
```



**复杂度分析：**

时间复杂度 O(NlogN) ： N 为 nums数组的长度  ；使用内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N <sup> 2 </sup>) 。

空间复杂度 O(N) ： 字符串数组 nums占用线性大小的额外空间。



## 33、丑数

**解题思路：**

我们先看到题目，把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。

有了上面的定义我们就可以知道，丑数的形式就是**2<sup>x</sup>3<sup>y</sup>5<sup>z</sup>**
所以我们可以定义一个数组res，存储第n个丑数。
因为我们要将丑数按从小到大的顺序排序，所以我们就得将对应的丑数放在对应的下标位置，小的放前面。
因为最小的丑数就是1，所以我们初始化res[0]=1，那么接下来的一个丑数是什么呢？我们自己知道是2。
但是我们能不能有一个格式，去将得到接下来的丑数是谁呢？
这个时候上面我们的出来的丑数的格式就起作用了，丑数的形式无非就是这样**2<sup>x</sup>3<sup>y</sup>5<sup>z</sup>**
所以我们就将res[n]去乘以 2、3、5，然后比较出最小的那个，就是我们当前的下一个丑数了。



![33](https://gitee.com/lgaaip/img/raw/master/33.gif)

**代码：**

```java
public int GetUglyNumber_Solution(int index) {
        //1 2 3 4 5 6 8
        if(index <= 6)
            return index;   // 加快程序输出
    
    	// 三个变量 后面有大作用！
        int i2 = 0,i3 = 0,i5 = 0;
        int[] res = new int[index];
        res[0] = 1;  // 第一个丑数为 1
        
        for(int i = 1; i < index; i++){
            // 得到下一个丑数，三者中最小的
            res[i] = Math.min(res[i2]*2,Math.min(res[i3]*3,res[i5]*5));
             /*第一次是 2、3、5比较，得到最小的是2*/
            /*第二次是 4、3、5比较，为什么是4了呢？因为上次2已经乘了一次了，所以接下去可以放的丑数在4、3、5之间*/
            // 所以开头的三个指针就是来标记2 3 5 乘的次数的 
            if(res[i] == res[i2]*2)
                i2++;
            if(res[i] == res[i3]*3)
                i3++;
            if(res[i] == res[i5]*5)
                i5++;
        }
        return res[index-1];
    }
```

上面说的可能有点小拗口，但是只要按照代码然后看上面的动图自己动手去理解，就可以很快的搞懂它了~



**复杂度分析：**

- 时间复杂度：O(n)。取决于index值，循环中计算的次数为index。
- 空间复杂度：O(n)。取决于数组res的大小。



## 34、第一个只出现一次的字符

**解题思路**：

这道题目很好理解，就是找出第一个只出现一次的字符。做法也很简单



**方法一：**哈希表

1、将字符当成哈希表中的key，第一次出现时候为true，重复出现则置为false；

2、遍历数组，拿到第一个在哈希表中的value为true的字符。

来看两张动图，简单易懂理解这种做法：

`先初始化哈希表`

![34_1](https://gitee.com/lgaaip/img/raw/master/34_1.gif)

`继续遍历字符数组，获取第一个在哈希表中value为true的字符`

![34_2](https://gitee.com/lgaaip/img/raw/master/34_2.gif)

看完之后我们直接上代码：

```java
public int FirstNotRepeatingChar(String str) {
        HashMap<Character,Boolean> map = new HashMap<>();
        char[] chars = str.toCharArray();
    	// 初始化哈希表，重复出现的置为false，否则为true
        for(char c:chars){
            if(map.containsKey(c)){
                map.put(c,false);
            }else{
                map.put(c,true);
            }
        }
    	// 二次遍历字符数组，若其在哈希表中的value为true，则返回下标
        for(int i = 0; i < chars.length; i++){
            if(map.get(chars[i])){
                return i;
            }
        }
    	// 没有符合条件的则返回-1
        return -1;
    }
```

**复杂度分析：**

时间复杂度： O(N)。N为字符串的长度，因为需要遍历两轮字符串，所以为2N，使用大O表示法则为O(N)。

空间复杂度：O(1)。使用到的辅助空间为哈希表的空间，由于题目给出所出现的字符为大小写字母，所以也就是说只需要占用O(32)的空间，则空间复杂度为O(1)，常数级别。



**方法二：**数组

巧妙利用字母的ASCII码，因为我们知道小写字母z的ASCII码值为122。所以我们可以使用计数的方法，开辟一个空间为123（数组下标从0开始）的数组，使用ASCII码（对应数组的下标）表示字母，去统计字母出现的次数。

最后我们只需要遍历一遍字符串，找到那个只出现一次的字符即可。由于很简单，我们直接看代码：

```java
public int FirstNotRepeatingChar(String str) {
    	// 开辟一个数组
        int[] dp = new int[123];  // 存储字母出现的次数  例如: dp[122] = 2，表示:小写字母z，出现了两次
    	// 统计出现的次数
        for (int i = 0; i < str.length(); i++) {
            dp[str.charAt(i)]++;
        }
    	// 遍历字符串，若字符只出现一次，则返回下标
        for (int i = 0; i < str.length(); i++) {
            if (dp[str.charAt(i)] == 1)
                return i;
        }
        return -1;
    }
```



**复杂度分析：**

时间复杂度：O(N)。字符串的长度。

空间复杂度：O(1)。由题目可知只包含大小写字母，所以开辟了一个O(123)的数组，最后可以看作为O(1)的空间复杂度。



## 35、数组中的逆序对







## 36、两个链表的第一个公共结点

**解题思路：**

使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。

让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。

因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能够到达同时到达终点。

（N1最后肯定能到达链表2的终点，N2肯定能到达链表1的终点）。

所以，如何得到公共节点：

- 有公共节点的时候，N1和N2必会相遇，因为长度一样嘛，速度也一定，必会走到相同的地方的，所以当两者相等的时候，则会第一个公共的节点
- 无公共节点的时候，此时N1和N2则都会走到终点，那么他们此时都是null，所以也算是相等了。

下面看个动态图，可以更形象的表示这个过程~

![36](https://gitee.com/lgaaip/img/raw/master/36.gif)

代码：

```java
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode l1 = pHead1, l2 = pHead2;
        while(l1 != l2){
            l1 = (l1==null)?pHead2:l1.next;
            l2 = (l2==null)?pHead1:l2.next;
        }
        return l1;
    }
```

**复杂度分析：**

时间复杂度：O(m+n)。链表1和链表2的长度之和。

空间复杂度：O(1)。常数的空间。





## 37、数字在升序数组中出现的次数

