::: tip
学习框架必须知其然而知其所以然，要学会底层原理，有朝一日方能设计框架
:::

## 一、什么是IOC

IOC（Inversion of Control）就是**控制反转**，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做**依赖注入**（Dependency Injection，简称**DI**），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。

**控制反转**简单来说就是：“你不需要来找我，我自己去找你”

举个例子： 现在我们在类A中需要用到类B的对象

- 传统的方式：就是在类A中去new出来一个类B的对象

- 使用IOC技术：此时在我们类A中，只需要去定义一个类B的对象，而不需要像传统的方式去new出来。它是通过IOC容器在外部将类B的对

  象new出来，然后再注入到类A中去。所以，我们需要哪个对象，就可以在容器中拿。

`以上的两种方式：`无非就是将我本身具有的权力（能去主动创建对象），交给了IOC容器，使得我们自己再也不需要去考虑创建哪个对象了。

## 二、DI （依赖注入）

**说到IOC就不得不说到DI。**

DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。

`注入的两种方式`

- Setter方式（传值方式）
- 构造器方式（引用方式）

`依赖注入的时间`

- 当我们第一次通过getBean去向IOC容器获取Bean，此时会触发依赖注入
- 当我们在Spring的配置文件.xml中配置Bean的属性`lazy-init`属性的时候，即关闭懒加载，这时候容器在注册bean 的时候就会进行实例化，此时触发依赖注入

>  PS：懒加载就是当我们容器去注册bean 的时候，不会创建对象，等到我们真正调用到的时候才回去加载对象，Spirng默认是开启懒加载		的。
>
> - 优点：对象使用的时候才去创建，节省资源。
> - 缺点：不利于提前发现错误。

## 三、IOC 解决了什么问题？

**1、对象之间的耦合度或者说依赖程度降低**

- 我们都知道判断一个程序的好坏，耦合性的高低是个重点，因为这涉及到你程序的可维护性。所以IOC很好的优化了这一点。

**2、资源能够更好的管理**

- 当你需要使用一个实现类的对象时候，可以直接从容器中拿到，然后很容易的可以实现一个单例。



下面详细的来说一下IOC：

>  阿蓝前期在学习的时候在CSDN上面看到一个生动的例子，我觉得很好的向我们展示了控制反转的好处。

**生动的例子如下：**

假设我们设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。

![image-20200809162231421](https://gitee.com/lgaaip/img/raw/master/img/20200809162239.png)

> 这个时候，如果我们的顶头上司要求我们将轮子换大一码，那么这下子就麻烦了，按照轮子量身定做的底盘，还有车身以及汽车。就都得全部重新设计了。这样的可维护性就非常的低！

我们换一种想法，们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，依赖关系就倒置过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。

![image-20200809162538045](https://gitee.com/lgaaip/img/raw/master/img/20200809162538.png)

> 这样子之后，如果要将轮子换大一码，就只需要更改一下轮子的设计，而不用去全部改动全部的配件。

这个例子很好的像我们展示了 控制倒置原则。

我们的IOC 就是依赖倒置原则的一种代码设计思路，然后采用的方法就是DI（依赖注入）这三者的关系是：

![image-20200809163058141](https://gitee.com/lgaaip/img/raw/master/img/20200809163059.png)

> 讲到最后，在来一个例子彻底了解完IOC

例如：现在有个User的实体类，然后需要对User进行开发操作，利用service和Dao层进行开发

首先我们传统的方式：

![image-20200809164039887](https://gitee.com/lgaaip/img/raw/master/img/20200809164040.png)

>  此时我们可以看到Dao层只有一个实现类，这样其实还看不出什么差别。但是要是Dao层多了一个实现类。举个例子，我们在Service层中，去对Dao层进行操作，将User分为两大类，一个是员工，一个是领导。那么这个时候Dao层就需要多一个实现类了。此时，当我们要调用Dao层的时候，就需要去改Service中的代码，new出来我们想要的对象。

![image-20200809164413959](https://gitee.com/lgaaip/img/raw/master/img/20200809164414.png)

然后我们使用`IOC`，将控制权交给`IOC容器`去管理，在需要用到的时候去容器中拿

![image-20200809164922547](https://gitee.com/lgaaip/img/raw/master/img/20200809164923.png)

这样的话，我们就不用在Service中写过多的new去创建出我们所依赖的对象了，而只需要自己去维护好中间的这个配置文件（`.xml文件`）,学过Spring的应该也都清楚。这样也大大较少了我们的代码量！

> 说到底，其实就记住一句话，什么是控制反转呢？
>
> 其实本质上就是将内置对象的控制权交给了容器。



## 四、说说你对Spring容器的理解
`BeanFactory：`是基础类型的IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。
> BeanFactory是一个类工厂，与传统类工厂不同的是，BeanFactory是类的通用工厂，它可以创建并管理各种类的对象。这些可被创建和管理的对象本身没有什么特别之处，仅是一个POJO，Spring称这些被创建和管理的Java对象为Bean。并且，Spring中所说的Bean比JavaBean更为宽泛一些，所有可以被Spring容器实例化并管理的Java类都可以成为Bean。
BeanFactory是Spring容器的顶层接口，Spring为BeanFactory提供了多种实现，最常用的是XmlBeanFactory。但它在Spring 3.2中已被废弃，建议使用XmlBeanDefinitionReader、
DefaultListableBeanFactory替代。BeanFactory最主要的方法就是 getBean(String beanName) ，该方法从容器中返回特定名称的Bean。


`ApplicationContext：`它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。

## 五、Bean的作用域
作用域限定了Spring Bean的作用范围，在Spring配置文件定义Bean时，通过声明scope配置项，可以灵活定义Bean的作用范围；或者通过@Scope注解修改Bean的作用域。scope的取值有5个，它们代表的了Bean5种不同类型的作用域：
|类型|说明|
|---|---|
|singlen|使用该属性定义Bean时，IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。|
|prototype|使用该属性定义Bean时，IOC容器可以创建多个Bean实例，每次返回的都是一个新的实例。|
|request|该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境。|
|session|该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。|
|global-session|该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例。|



## 六、Bean的生命周期



## 七、Spring是怎么解决循环依赖的