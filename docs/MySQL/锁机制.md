# MySQL中的锁机制


## 一、锁分类（按照锁的粒度分类）

**MySQL为了解决并发、数据安全的问题，使用了锁机制。**

<font color='cornflowerblue'>可以按照锁的粒度把数据库锁分为表级锁和行级锁</font>。

- **表级锁**

  MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单 **，资源消耗也比较少，加锁快，不会出现死锁** 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。

- **行级锁**

  MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 **行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。** 

**虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的**：

- 事务更新大表中的大部分数据直接使用表级锁效率更高；
- 事务比较复杂，使用行级索很可能引起死锁导致回滚。

## 二、 锁分类（按照是否可写分类）

<font color='red'>**表级锁和行级锁可以进一步划分为共享锁（s）和排他锁（X）。**</font>

- <font color='cornflowerblue'>**共享锁（s）**</font>：允许事务读一行数据。

  **共享锁（Share Locks，简记为S）又被称为读锁**，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。

  共享锁(S锁)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

- <font color='cornflowerblue'>**排他锁（X）：**</font>允许事务删除或更新一行数据。

  **排他锁（(Exclusive lock,简记为X锁)）又称为写锁**，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。

> 如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获取行r的共享锁，因为读取并没有改变行r的数据，这种情况称为 <font color='green'>锁兼容</font>。但是若有其他的事务T3想获得行r的排他锁，则其必须等待事务T1,T2释放行r上的共享锁，这种情况称为 <font color='green'>锁不兼容</font>

<font color='red'>注意：</font>S和X锁都是行锁，兼容是指对同一记录锁的兼容情况。

<font color='green'>**两者之间的区别：**</font>

1. <font color='orange'>共享锁（S锁）</font>：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不 能加排他锁。获取共享锁的事务只能读数据，不能修改数据。
2. <font color='orange'>排他锁（X锁）</font>：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获取排他锁的事务既能读数据，又能修改数据。

## 三、 另外两个表级锁：IS和IX

当一个事务需要给自己需要的某个资源加锁的时候，如果遇到一个共享锁正锁定着自己需要的资源的时候，自己可以再加一个共享锁，不过不能加排他锁。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。

而**意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以需要锁定行的表上面添加一个<font color='orange'>合适的意向锁</font>。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。<font color='cornflowerblue'>意向共享锁</font>可以同时并存<font color='red'>多个</font>，但是<font color='cornflowerblue'>意向排他锁</font>同时只能有<font color='red'>一个</font>存在。**

<font color='green'>**InnoDB另外的两个表级锁：**</font>

- <font color='cornflowerblue'>**意向共享锁（IS）：**</font> <font color='orange'>事务想要获得一张表中某几行的共享锁。</font>

  表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。

- <font color='cornflowerblue'>**意向排他锁（IX）：** </font><font color='orange'>事务想要获得一张表中某几行的排他锁。</font>

  表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。

**注意：**

1. **这里的意向锁是表级锁，表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行锁时才会判断是否冲突。意向锁是InnoDB自动加的，不需要用户干预。**
2. <font color='red'>**IX，IS是表级锁，不会和行级的X，S锁发生冲突，只会和表级的X，S发生冲突。**</font>



**InnoDB的锁机制兼容情况如下：**
![InnoDB的锁机制兼容情况](https://gitee.com/lgaaip/img/raw/master/20210306200847.png)

**当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事物就等待锁释放。**



## 四、锁的算法

**InnoDB存储引擎有3种行锁的算法，其分别是：**

- Record Lock：单个行记录上的锁。

- Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。

- **<font color='red'>Next-Key Lock</font>**∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。

Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。Next-Key Lock是结合了Gap Lock和RecordLock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。采用Next-Key Lock的锁定技术称为Next-Key Locking，其设计的目的是为了解决**Phantom Problem（幻读）**。而利用这种锁定技术，锁定的不是单个值，而是一个范围，是谓词锁（predict lock）的一种改进。



## 五、 死锁和避免死锁

<font color='red'>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。</font>

下图演示了死锁的一种经典的情况，即A等待B、B等待A，这种死锁问题被称为AB-BA死锁。

<img src="https://gitee.com/lgaaip/img/raw/master/20210306190013.png" alt="image-20210306190012216" style="zoom:80%;" />

**<font color='cornflowerblue'>解决死锁的方法</font>**：

1. 解决死锁的最简单方式就是不要有任何的等待，将任何的等待转化为<font color='orange'>回滚</font>。但是这可能导致并发性能的下降，甚至任何一个事务都不能进行。这比死锁更为严重，因为这很难被发现而且<font color='orange'>浪费资源</font>。
2. 还有另外一种简单的方法就是<font color='orange'>超时</font>。当两个事务进行等待时，当一个等待时间超过设置的阈值时，其中一个事务进行回滚，另外一个事务就继续进行（FIFO）。但是这样也有一个问题，就是当超时的事务所占的权重较大，这个事务的<font color='orange'>回滚的时间可能比执行的事务还要久</font>。
3. 数据库普遍采用<font color='orange'>wait-for graph（等待图）</font>的方式检测死锁。构造图，若存在回路，则说明存在死锁，此时InnoDB存储引擎选择回滚undo量最小的事务。



**InnoDB的行级锁是基于索引实现的，如果查询语句为命中任何索引，那么InnoDB会使用表级锁.** 此外，InnoDB的行级锁是针对索引加的锁，不针对数据记录，因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突，还需要注意的是，在通过

```sql
SELECT ...LOCK IN SHARE MODE;1
```

或

```sql
SELECT ...FOR UPDATE;1
```

使用锁的时候，如果表没有定义任何索引，那么InnoDB会创建一个隐藏的聚簇索引并使用这个索引来加记录锁。

此外，**不同于MyISAM总是一次性获得所需的全部锁，InnoDB的锁是逐步获得的，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁。** 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务，我们可以采取以上方式避免死锁：

- **通过表级锁来减少死锁产生的概率；**
- **多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；**
- **同一个事务尽可能做到一次锁定所需要的所有资源。**

## 六、 总结与补充

>  <font color='cornflowerblue'>间隙锁</font>

InnoDB存储引擎有3种行锁的算法，间隙锁（Gap Lock）是其中之一。间隙锁用于锁定一个范围，但不包含记录本身。它的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生。

>  <font color='cornflowerblue'>InnoDB中行级锁是怎么实现的？</font>

InnoDB行级锁是通过给索引上的索引项加锁来实现的。只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。

当表中锁定其中的某几行时，不同的事务可以使用不同的索引锁定不同的行。另外，不论使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁。



**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用<font color='orange'>表级锁</font>(table-level locking)。
- InnoDB支持<font color='orange'>行级锁</font>(row-level locking)和<font color='orange'>表级锁</font>,默认为<font color='orange'>行级锁</font>

**表级锁和行级锁对比：**

- **表级锁：** MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
- **行级锁：** MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

**补充：**

**页级锁：** MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。页级进行了折中，一次锁定相邻的一组记录。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。