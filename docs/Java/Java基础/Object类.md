# Object类

Java中有一个比较特殊的类，就是 Object类，它是所有类的父类，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类就默认继承 Object类。因此，Object类是 Java 类层中的最高层类，是所有类的超类。换句话说，Java 中任何一个类都是它的子类。由于所有的类都是由 Object类衍生出来的，所以 Object类中的方法适用于所有类。

## 方法介绍

![image-20210304082936402](https://gitee.com/lgaaip/img/raw/master/20210304082944.png)

Object类提供了如下几个常用方法：

- void registerNatives：将该类中的所有本地方法进行注册。[详解可参见](https://blog.csdn.net/Saintyyu/article/details/90452826)

- Class<?> getClass()：本地方法，返回该对象的运行时类。

- `boolean equals(Object obj)：`判断指定对象与该对象是否相等。

- `int hashCode()：`本地方法，返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的地址来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。

- `String toString()：`返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 运行时类名@十六进制hashCode值 格式的字符串，但很多类都重写了Obect类的toString()方法，用于返回可以表述该对象信息的字符串。

- Object clone()：本地方法，用于帮助其它对象完成一个自我克隆，所谓的自我克隆就是得到一个当前对象的副本，而二者之间完全隔离。
- `void notify()`：本地方法，唤醒正在等待对象监视器的单个线程
- `void wait()`：本地方法，导致当前线程等待，直到另外一个线程调用该对象的notify方法或者notifyAll()方法

> Object类还提供了一个finalize()方法，当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。并且，针对某一个对象，垃圾回收器最多只会调用它的finalize()方法一次。注意，finalize()方法何时调用、是否调用都是不确定的，我们也不要主动调用finalize()方法。从JDK9开始，这个方法被标记为不推荐使用的方法。



## **说一说**hashCode()和equals()的关系

`hashCode()`用于获取哈希码（散列码），`eauqls()`用于比较两个对象是否相等，它们应遵守如下规定：

- 如果两个对象相等，则它们必须有相同的哈希码。

- 如果两个对象有相同的哈希码，则它们未必相等。

> 在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。
>
> 当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。HashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。

## 为什么要重写hashCode()和equals()?

我们来看一下equals在Object中的源码

```java
public boolean equals(Object obj) {
        return (this == obj);
    }
```

Object类提供的equals()方法默认是用 `== `来进行比较的，也就是说只有两个对象是同一个对象时，才能返回相等的结果。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。鉴于这种情况，Object类中equals()方法的默认实现是没有实用价值的，所以通常都要重

写。（后面我们分析String类的时候，String类中就重写了这个方法，我们到时候可以看一下）

由于hashCode()与equals()具有联动关系，所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定。

## ==和equals的区别？

`==运算符：`

- 作用于基本数据类型时，是比较两个数值是否相等；

- 作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象；

`equals()方法：`

- 没有重写时，Object默认以 == 来实现，即比较两个对象的内存地址是否相同；

- 进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。 