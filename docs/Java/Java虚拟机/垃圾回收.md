# 垃圾回收

**垃圾回收可分为两个阶段：标记阶段、清除阶段。**

## Java的垃圾回收机制

### 一、哪些内存需要回收

在Java内存运行时区域的各个部分中，堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理，我们平时所说的内存分配与回收也仅仅特指这一部分内存。

### 二、怎么定义垃圾

<font color='cornflowerblue'>标记阶段的作用：对象的存活判断。</font>

- 引用计数法
- 可达性分析法

#### 引用计数法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。

**优点:**  

- 实现简单，垃圾对象便于辨识;判定效率高，回收没有延迟性。

**缺点:**  

- 它需要单独的字段存储计数器，这样的做法增加了<font color='cornflowerblue'>存储空间的开销</font>。
- 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<font color='cornflowerblue'>时间开销</font>。
- 引用计数器有一个严重的问题，即<font color='cornflowerblue'>无法处理循环引用</font>的情况。<font color='red'>这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</font>

> 举个简单的例子：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。



----



#### 可达性分析算法
（根搜索算法、追踪性垃圾收集）

相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。

相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（ Tracing Garbage Collection）。



当前主流的商用程序语言的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“`GC Roots`”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

如下图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。

​       ![image-20210306103114449](https://gitee.com/lgaaip/img/raw/master/20210306103115.png)



**GC Roots**

在Java 语言中，GC Roots包括以下几类元素

- <font color='red'>虚拟机栈中引用的对象</font>

  - 比如:各个线程被调用的方法中使用到的参数、局部变量等。

- <font color='red'>本地方法栈内JNI(通常说的本地方法)引用的对象</font>
- <font color='red'>方法区中类静态属性引用的对象</font>

  - 比如: Java类的引用类型静态变量

- <font color='red'>方法区中常量引用的对象</font>

  - 比如:字符串常量池（ string Table）里的引用

- 所有被同步锁synchronized持有的对象
- Java虚拟机内部的引用。

  - 基本数据类型对应的class对象，一些常驻的异常对象（如:NullPointerException、OutOfMemoryError)，系统类加载

- 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

**注意：**如果要使用可达性分析算法来判断内存是否可回收，那么分析工作**必须在一个能保障一致性的快照中进行**。这点不满足的话分析结果的准确性就无法保证。



----

#### finalization机制

Java语言提供了对象终止（finalization）机制来允许开发人员提供**对象被销毁之前的自定义处理逻辑。**

当垃圾回收器发现没有引用指向一个对象，总会先调用这个对象的**`finalize()`**方法。

`finalize()`方法允许在子类中被重写，**用于在对象被回收时进行资源释放。**比如关闭文件、套接字和数据库连接等。

**<会出面试题>**

由于`finalize()`方法的存在，**虚拟机中的对象一般处于三种可能的状态**。

- **可触及的** 从根节点开始，可以到达这个对象
- **可复活的** 对象的所有引用都被释放，但是对象有可能在finalize()中复活。
- **不可触及的** 对象的finalize()被调用，并且没有复活，那么会进入不可触及的状态。不可触及的对象不可能被复活。因为**finalize()只会被调用一次。**

finalize()方法相当于给对象要回收前设置了一个<font color='red'>“缓刑”</font>阶段。

> **具体过程**

判定一个对象A是否可回收，至少要经历两次标记过程：

1. 如果对象A到GC Roots没有引用链，则进行第一次标记。
2. 进行筛选，判断对象是否有必要执行finalize()方法

  - 如果对象A没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为**没有必要执行**，A被判定为**不可触及的**。
  - 如果A重写了finalize()方法，且还没有执行过，那么A会被插入到`F-Queue`队列中，由一个虚拟机自动创建的、低优先级的`Finalizer`线程触发其`finalize()`方法执行。
  - `finalize()`是方法是对象逃脱死亡的最后机会，如果A在`finalize()`方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，A会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况，这时`finalize()`方法不会被再次调用，对象会直接变成不可触及状态。

代码测试：

```java
public class CanReliveObj {
    // 类变量，属于GC Roots的一部分
    public static CanReliveObj canReliveObj;

    //此方法只能被调用一次
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("调用当前类重写的finalize()方法");
        canReliveObj = this; //当前待回收的对象再finalize()方法中与引用链上的任意一个对象建立了联系
    }

    public static void main(String[] args) throws InterruptedException {
        canReliveObj = new CanReliveObj();
        canReliveObj = null;
        System.gc();
        System.out.println("-----------------第一次gc操作------------");
        // 因为Finalizer线程的优先级比较低，暂停2秒，以等待它
        Thread.sleep(2000);
        if (canReliveObj == null) {
            System.out.println("obj is dead");
        } else {
            System.out.println("obj is still alive");
        }

        System.out.println("-----------------第二次gc操作------------");
        canReliveObj = null;
        System.gc();
        // 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了
        Thread.sleep(2000);
        if (canReliveObj == null) {
            System.out.println("obj is dead");
        } else {
            System.out.println("obj is still alive");
        }

    }
}
```

运行结果：

![img](https://gitee.com/lgaaip/img/raw/master/20210306104355.png)

#### 回收方法区

方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。回收废弃常量与回收Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断的确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。

- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。

- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 三、怎么回收垃圾

**清除阶段：**当成功区分出哪些是活对象哪些是死对象后，GC接下来的任务就是执行垃圾收集，释放掉无用对象所占用的内存空间。有三种垃圾收集算法。

#### **<font color='orange'>标记-清除算法</font>**

- **标记-清除算法（Mark-Sweep）**  比较基础和常见当堆中的有效内存空间被耗尽时，就会**STW（stop the world）**（在一个安全点上暂停整个程序），然后进行两项工作。

  - **标记**  GC从引用根节点开始遍历，**标记所有被引用的对象**。一般是在对象的Header中记录为可达对象。
  - **清除** GC从堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

![image-20210306104615471](https://gitee.com/lgaaip/img/raw/master/20210306104616.png)

**缺点：**

  - 效率不算高 （因为进行了两次遍历，第一次标记，第二次清除）
  - 进行GC时，需要停止整个应用程序，导致用户体验差
  - 清理出来的空闲内存是不连续的，产生内部碎片。需要维护一个空闲列表

> 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。



#### **<font color='orange'>标记-复制算法</font>**

- **复制算法（Copying）**为了解决标记-清除算法在效率方面的缺陷，在1963年提出了复制算法。将活着的内存空间分成两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到另外一块，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。其实新生代里就用到了该算法。s0和s1

![image-20210306105435105](https://gitee.com/lgaaip/img/raw/master/20210306105436.png)

- 优点：

- - 没有标记和清除两个过程，实现简单，运行高效
  - 复制过去以后保证了空间的连续性，不会出现“内存碎片”

- 缺点：

- - 需要**两倍**的内存空间。
  - 对于G1这种分拆成大量的region的GC，该算法还得GC维护下region之间对象引用关系。因为java使用的是直接指针访问。所以不管是内存占用还是时间开销，还是不小的。
  - 如果存活对象特别多的话，复制算法不会很理想。所以它的高效性是**建立在存活对象少，垃圾对象多的前提下的**。适合新生代。
  - 应用场景：新生代（朝生夕死）一次通常可以回收70%-99%的内存空间。

- 

####  <font color='orange'>**标记-压缩算法**</font>

（Mark-Compact）

- **标记-压缩算法(Mark-Compact)** 老年代大部分对象是存活对象。也是有两个过程标记过程从根节点开始标记所有被引用对象压缩：将所有存活对象压缩到内存的一端，按顺序排放，之后再清理边界外所有的空间。

  针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（MarkCompact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如下图所示。

  ![image-20210306105645486](https://gitee.com/lgaaip/img/raw/master/20210306105646.png)

- 优点：

  - 消除了标记-清除算法中内存碎片问题，也不需要去维护一个空闲列表，而是采用指针碰撞的方式。
  - 消除了复制算法中内存减半的高额代价。

- 缺点：

  - 从效率上看，标记-整理算法要低于复制算法。
  - 移动对象的同时，还得调整引用的地址。
  - 移动过程中，需要全程暂停用户应用程序STW（stop the world）。

![img](https://gitee.com/lgaaip/img/raw/master/20210306105844.png)

分代收集理论：

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（GenerationalCollection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。

2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

#### **分代收集算法**

这不是一种类似上面三种具体的算法。而是**根据对象存活周期的不同将内存划分为几块**。一般java堆分为新生代和老年代。然后根据每个块的特点选择合适的垃圾回收算法。

比如在<font color='orange'>新生代</font>中，因为有大量的垃圾对象，所以选择<font color='cornflowerblue'>复制算法</font>，而幸存者0和1区的占用也很小。而<font color='orange'>老年代</font>的对象存活率比较高，而且没有额外的空间做分配担保，所以我们选择<font color='orange'>标记-清除或标记-整理算法</font>进行垃圾收集。

而HotSpot进行分区，也是为了**提高GC效率**。

**目前所有的GC都是采用<font color='red'>分代收集算法</font>执行垃圾回收的。**



## Stop The Word是什么？

stop-the-world ，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。

可达性分析算法中枚举根节点(GC Roots）会导致所有Java执行线程停顿。

- 分析工作必须在一个能确保一致性的快照中进行
- 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
- 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。

