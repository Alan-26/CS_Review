# JMM内存模型（JMM）

> 是一种规范，约定俗成的，切记不要和JVM内存模型混淆，两者是不同的。

在学习这个JMM内存模型的时候，我们先来一段代码测试一下：

![image.png](https://gitee.com/lgaaip/img/raw/master/20210306002329.png)

> **运行结果为**

![image.png](https://gitee.com/lgaaip/img/raw/master/20210306002332.png)

从这个Demo中我们可以知道，flag刚开始是false，在线程A中会进去一个无限循环，在线程B中去将flag置为了true，然后线程A中对于线程B去更改flag是不可见的，所以它进入了无限循环。

**所以下面的JMM就是为了解决这一问题的存在。**



**JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。**

**关于**JMM的一些同步的约定：

1、线程解锁前，必须把共享变量**立刻**刷回主存。

2、线程加锁前，必须读取主存中的最新值到工作内存中！

3、加锁和解锁是同一把锁



**八种操作**

![image.png](https://gitee.com/lgaaip/img/raw/master/img/20210125221334.png)



**内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外**

**lock** **（锁定）：**作用于主内存的变量，把一个变量标识为线程独占状态

**unlock （解锁）：**作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

**read （读取）：**作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用

**load （载入）：**作用于工作内存的变量，它把read操作从主存中变量放入工作内存中

**use （使用）：**作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令

**assign （赋值）：**作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中

**store （存储）：**作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用

**write** **（写入）：**作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中



**JMM**对这八种指令的使用，制定了如下规则：

- 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
- 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
- 不允许一个线程将没有assign的数据从工作内存同步回主内存
- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作
- 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
- 对一个变量进行unlock操作之前，必须把此变量同步回主内存



# Volatile

Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。

## 谈谈Volatile的实现原理

volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

2. 它会强制将对缓存的修改操作立即写入主存；

3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。



## Volatile有什么用？

当一个变量被定义成volatile之后，它将具备两项特性：

1. **保证可见性**

   当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，这个写会操作会导致其他线程中的volatile变量缓存无效。

2. **禁止指令重排**

   使用volatile关键字修饰共享变量可以禁止指令重排序，volatile禁止指令重排序有一些规则：

   - 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行；
   - 在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

   即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。

注意，虽然volatile能够保证可见性，但它不能保证原子性。volatile变量在各个线程的工作内存中是不存在一致性问题的，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。

## 禁止重排序

volatile 禁止了指令重排。

> volatile是不保证原子性的（对单个变量保证原子性），如果要解决这一问题，除了 **lock和synchronized**，还可以用原子类。

`问题来了，既然它可以保证修改的值立即能更新到主存，其他线程也会捕捉到被修改后的值，那么为什么不能保证原子性呢？`

首先需要了解的是，Java中只有对基本类型变量的赋值和读取是原子操作，如i = 1的赋值操作，但是像j = i或者i++这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。

所以，如果一个变量被volatile修饰了，那么肯定可以保证每次读取这个变量值的时候得到的值是最新的，但是一旦需要对变量进行自增这样的非原子操作，就不会保证这个变量的原子性了。

**<font color='cornflowerblue'>例子：</font>**

> 一个变量i被volatile修饰，两个线程想对这个变量修改，都对其进行自增操作也就是i++，**<font color='red'>i++的过程可以分为三步，首先获取i的值，其次对i的值进行加1，最后将得到的新值写会到缓存中。</font>**
> 线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也得到了i的值，由于i的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。
> 问题来了，线程A已经读取到了i的值为100，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。

 

**`比sychronized更轻量级的同步锁`**

在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。

![image-20210125221926870](https://gitee.com/lgaaip/img/raw/master/img/20210125221928.png)

当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。





## 适用场景

值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：

 （1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。 

（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。

应用：状态变量（boolean flag = true），**`单例模式`**



## 对比synchronized

synchronized 关键字和 volatile 关键字是两个互补的存在，⽽不是对⽴的存在！

- **volatile** 关键字是线程同步的轻量级实现，所以 **volatile** 性能肯定⽐ **synchronized** 关键字要好。但是 **volatile** 关键字只能⽤于变量⽽ **synchronized** 关键字可以修饰⽅法以及代码块。
- **volatile** 关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 **synchronized** 关键字两者都能保证。
- **volatile** 关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ **synchronized** 关键字解决的是多个线程之间访问资源的同步性。