# 日志系统

**1、redo log的概念是什么? 为什么会存在.**

redo log是innodb引擎特有的日志系统，它主要记录的是 ”在某个数据页上做了什么修改“。redo log的存在，保证了mysql的更新效率，并且保证了crash safe机制。

**2、什么是WAL(write-ahead log)机制, 好处是什么**

WAL的意思就是先写日志，再写磁盘，保证了mysql的更新效率。

具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

**3、redo log 为什么可以保证crash safe机制.**

先来看一下redo log的工作原理

![image-20210705205849325](https://gitee.com/lgaaip/img/raw/master/image-20210705205849325.png)

write pos表示当前记录的位置，边写边往后移。（即写的位置）

check point表示当前要擦除的位置，也是边擦边后移。（即更新到磁盘的位置）

write pos和checkpoint之间的空闲部分没满的时候，证明此时redo log还没满，则还能继续写。

若满了之后，此时则无法继续写，需要停下来先擦入磁盘，推进cheak point，然后给出空闲的空间。

所以有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。



**4、binlog的概念是什么, 起到什么作用, 可以做crash safe吗?**

binlog是mysql Server层就有的日志系统，为归档日志。

它主要是记录操作的sql语句。

> binlog 有两种模式，statement 格式的话是记 sql 语句，row 格式会记录行的内容，记两条，更新前和更新后都有。
>
> sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

binlog主要可以用于主从同步，以及数据库基于时间点的还原。

binlog无法做crash safe，虽然 binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有。它和redo log完全不一样，redo log放的都是还没刷到磁盘上的数据，而binlog则无法确定。

**5、binlog和redolog的不同点有哪些?**

1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。
3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。



**6、 执行器和innoDB在执行update语句时候的流程是什么样的?**

![img](https://gitee.com/lgaaip/img/raw/master/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

**7、如果数据库误操作, 如何执行数据恢复?**

binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

- 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
- 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。

这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。



 **8、什么是两阶段提交, 为什么需要两阶段提交?**

由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。

仍然用前面的update语句来做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？

1. **先写redo log后写binlog**。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。
   但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。
   然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。
2. **先写binlog后写redo log**。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。

可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。

你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？

其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。

简单说，redo log和binlog都可以用于表示事务的提交状态，而`两阶段提交就是让这两个状态保持逻辑上的一致`。

